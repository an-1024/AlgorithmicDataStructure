# 数组基础知识
数组在内存空间的分布是一段连续的地址，index 从 0 开始。所以对于数组的新增或者删除需要移动其他元素

# 二分查找

二分查找的核心在于定位边界问题：

第一个边界问题：循环的结束条件；

第二个边界问题：每次循环 **左右** 变量的赋值即每次循环开始的索引值；

## 二分查找思想：

首先了解二分的思想：

1. 首先将 **有序(这里以升序为例)** 数组分为大致相等的两个部分，即 nums.size/2；左右两部分数组nums[left], nums[right]；

2. 确定循环条件：当左边数组索引 left < right 或者 left <= right 时，循环结束；(为什么会有两种条件呢?)
   开发的都知道 数组下标是从 0 开始，所以 right 即 折半的索引取值决定了索引的区间，从而就决定了循环条件也会出现两种即 while(left < right)
   or while(left < right);

3. 当 right = nums.size - 1 表明 target 在[left, right] 区间里, 当 right = nums.size; 表明 target 在 [left, right) 区间里;

**注意**: 溢位的问题: 注意 miidle = (left + right)/2 可能会出现溢位，所以采取另一种方法: middle = left + ((right -left)/2);

4. 当 nums[middle] < target 表明 目标值在右区间, 反之在左区间;

根据分析，确定了边界问题后，开始编程吧。

# 长度最小的子数组

给定一个含有 n 个正整数的数组和一个正整数 target。找出该数组中满足其和 >= target
的长度最小的**连续**子数组 [nums[l], nums[l+1], ..., nums[r-l], nums[r]]，并返回其长度，
如果不存在符合条件的子数组， 返回 0。

## 暴力解法

双层 for 循环暴力求解，在数组中从开始不断地开始寻找最小的子串；

1. 第一层 for 循环，每次初始化最小求和 sum 值；因为每次都是重新计算；
2. 第二层 for 循环，计算数组中元素相加之和大于 target 的元素，并计算下标间隔长度 subLength，
   并比较上一次的长度，取最小值作为结果 result；
3. resul 结果是否重新被赋值，有则返回 0；否则返回 result值；

## 滑动窗口

滑动窗口就是不断地调节子数组的起始位置和终止位置，从而得出结果。

以滑动窗口解题首先要确定以下几个问题：

1. 窗口中的元素是什么？
2. 如何移动窗口的起始位置？
3. 如何移动窗口的终止位置？

该题的解题思路：

1. 确定窗口中的元素：nums >= target，即窗口内数值总和要 > 目标值 target；
2. 移动窗口的起始位置：如果当前窗口的值 > 目标值 target ，则窗口需要向前移动 即窗口缩小， 意味这 sum
   缩小了；
3. 窗口的结束位置就是 for 循环遍历数组的指针；


 



