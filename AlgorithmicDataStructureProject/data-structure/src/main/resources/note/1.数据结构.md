# 数据结构

什么是数据结构：

1. 数据结构是存放、组织数据的方式；
2. 数据结构是算法设计的基础；
3. 好的数据结构可以提升程序的运行效率，和存储效率；

# 基本的数据结构

## 数组

在内存中表现为连续的存储结构。因此便于寻址，不便于增删数据。

### 前缀和

前缀和是一种重要的预处理，能大大降低查询的时间复杂度。前缀和分为**一维前缀和**和**二维前缀和**。

### 一维前缀和

给定一个数组A[1,2,……n]，则它的前缀和数组为PrefixSum[1..n]。定义为：PrefixSum[i] = A[0]+A[1]+...+A[i-1]；

举个例子：

A[5,6,7,8] --> PrefixSum[5,11,18,26]

PrefixSum[0] =A[0] ;

PrefixSum[1] =A[0] + A[1] ;

PrefixSum[2] =A[0] + A[1] + A[2] ;

PrefixSum[3] =A[0] + A[1] + A[2] + A[3] ;
用法如下：

1. 可以通过前缀和求出任意区间的求和值，比如我们想求出[1,2]区间内的求和值，即s[2]-s[0]=[5,34]=29

代码实现：

```java
public class PrefixSumDemo {
    
    private static int[] preSum;
    
    public static void buildPrefixRangSum(int[] arr) {
        int N = arr.length;
        preSum = new int[N];
        preSum[0] = arr[0];
        
        for (int i = 1; i<N; i++) {
            preSum[i] = preSum[i - 1] + arr[i];
        }
    }
    
    public static int prefixRangeSum(int L, int R) {
        return L == 0 ? preSum[L] : preSum[R] - preSum[L - 1];
    }
}
```

### 二维前缀和

在数据量极大的情况下，二维前缀查效率要高于一维前缀和。

举个🌰

arr[1,5,3]

二维前缀和构建结果如下：
$$
\begin{bmatrix}
   1 & 6 & 9 \\
   x & 5 & 8 \\
   x & x & 3
  \end{bmatrix} \tag{4}
$$
相比于一维前缀和，二维前缀和可以直接取之，不用进行计算，这也是二维前缀和在数据量极大的情况下比一维前缀和高效的原因。

代码实现：

```java
public class PrefixSumDemo {

    private static int[] oneDimensionalPreSum;

    private static int[][] twoDimensionalPreSum;

    /**
     * 构建一维前缀和
     *
     * @param arr
     */
    public static void buildOneDimensionalPrefixRangSum(int[] arr) {
        int N = arr.length;
        oneDimensionalPreSum = new int[N];
        oneDimensionalPreSum[0] = arr[0];

        for (int i = 1; i < N; i++) {
            oneDimensionalPreSum[i] = oneDimensionalPreSum[i - 1] + arr[i];
        }
    }

    // 一维前缀用法
    public static int oneDimensionalPrefixRangeSum(int L, int R, int length) {
        if (L>length || R > length) {
            return 0;
        }
        return L == 0 ? oneDimensionalPreSum[L] : oneDimensionalPreSum[R] - oneDimensionalPreSum[L - 1];
    }

    public static void buildTwoDimensionalPrefixRangSum(int[] arr) {
        int N = arr.length;
        twoDimensionalPreSum = new int[N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                if (i == 0 && j == 0) {
                    twoDimensionalPreSum[0][0] = arr[0];
                    continue;
                } else if (j < i) {
                    continue;
                }
                twoDimensionalPreSum[i][j] = twoDimensionalPreSum[i][j - 1] + arr[j];
            }
        }
    }
    
    // 二维前缀和用法
    public static int twoDimensionalPrefixRangSum(int L, int R, int length) {
        if (L>length || R > length) {
            return 0;
        }
        return twoDimensionalPreSum[L][R];
    }

    public static void main(String[] args) {
        int[] arr = new int[]{1, 4, 6, 7};
        buildTwoDimensionalPrefixRangSum(arr);
        System.out.println(twoDimensionalPrefixRangSum(0,5, arr.length));
    }
}
```



## 链表

在内存中表现为不连续的存储结构。因此便于增删数据，不便于寻址。

## 随机函数

在 Java 中的随机函数是 `Math.random()`。该函数会等概率的随机返回一个[0,1) 的数。在数学中，等概率是不可能的，但是在计算机中，小数是有精度的，数学中是没有的。验证如下：

```java
/**
 * 验证 Math.random() 的等概率
 */
public class MathRandomDemo {
    public static void main(String[] args) {
        int count = 0;
        int loopCount = 1000;
        for (int i=0; i<loopCount; i++) {
            double random = Math.random();
            if (random < 0.3) {
                count++;
            }
        }
        System.out.println((double)count /( double) loopCount);
        
        int K = 9;
        // ans 在 [0,8] 必然是等概率的
        int[] record = new int[9];
        for (int i=0; i<loopCount; i++) {
            int ans = (int) (Math.random() * K);
            record[ans]++;
        }
        
        for (int i=0; i<K; i++) {
            System.out.println(i + " 出现了" + record[i] + " 次");
        }
    }
}
```

输出结果：

```txt
0.275
0 出现了103 次
1 出现了107 次
2 出现了126 次
3 出现了117 次
4 出现了115 次
5 出现了106 次
6 出现了107 次
7 出现了108 次
8 出现了111 次
```

 根据输出结果可以看到，[0,8] 出现的次数基本差不太多。由此可以得出，[0,x]，x出现的概率就是 x，那此时想让 [0,x] ，x 出现的概率是 x^2，怎么处理？

```java
/**
 * Math.random 的取值为[0,1)
 * x 属于 [0,1)，如何将 x 在 [0,1) 出现的概率由 x 调整为 x^2
 */
public class MathPowerRandom {

    public static void main(String[] args) {
        int count = 0;
        int loopCount = 10000;
        
        double x = 0.17;
        for (int i=0; i<loopCount; i++) {
            if (xToXThreePower() < x) {
                count++;
            }
        }

        System.out.println((double) count / (double) loopCount);
        System.out.println(Math.pow(x, 3));
    }
    
    // Math.random 值属于 [0,1)，
    // x 属于 [0,1)，将 x 在 [0,1) 出现的概率由原来的 x 调整为 x^2
    public static double xToXPower() {
        // 每个 Math.random() 都是独立的，调用了两次 Math.random()，只有两次都命中
        // 这个范围，那么最终返回的范围才是 [0,x]。第一个概率是 x，第二个也是 x，x^2
        return Math.max(Math.random(), Math.random());
    }
    
    // 那么 x^3 就是
    public static double xToXThreePower() {
        return Math.max(Math.random(), Math.max(Math.random(), Math.random()));
    }
}
```

输出结果

```txt
0.0044
0.004913000000000001
```

结果很相近。

那么用 `Math.min()`怎么处理呢？

首先确定得到 x 的概率是 x，那么没有得到 x 的概率就是 1-x，那么得不到 x^2 的概率就是 (1-x)^2， 那么 x^2 的概率就是 1 - (1-x)^2。所以：

```java
public class MathPowerRandom {

    public static void main(String[] args) {
        int count = 0;
        int loopCount = 10000;
        
        double x = 0.17;
        for (int i=0; i<loopCount; i++) {
            if (xToXPowerMin() < x) {
                count++;
            }
        }

        System.out.println((double) count / (double) loopCount);
        System.out.println((double) 1- Math.pow((double) 1-x, 2));
    }
  
  	public static double xToXPowerMin() {
        return Math.min(Math.random(), Math.random());
    }
}
```

输出结果

```txt
0.3198
0.31110000000000004
```

## 实现 1-5 随机等概率到 1-7 等概率随机

在使用 f() 函数实现整数 1-5 随机等概率。

