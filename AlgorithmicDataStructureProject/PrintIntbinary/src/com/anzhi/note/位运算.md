# 位运算
如何打印一个整数的二进制？在实现这段代码之前，先来了解一下计算机中对于整数是如何存储的。
# 原码、补码、反码

## 原码
定义：原码(true form)是一种[计算机](https://baike.baidu.com/item/计算机/140338?fromModule=lemma_inlink)中对数字的[二进制](https://baike.baidu.com/item/二进制/361457?fromModule=lemma_inlink)定点表示方法。原码表示法在数值前面增加了一位符号位（即最高位为符号位）：[正数](https://baike.baidu.com/item/正数/1294288?fromModule=lemma_inlink)该位为0，负数该位为1（0有两种表示：+0和-0），其余位表示数值的大小。

```txt
 9=0000 1001
-9=1000 1001
```

## 补码

补码（英语：2's complement）：是**一种用二进制表示有符号数的方法**，也是一种将数字的正负号变号的方式，常在计算机科学中使用。 补码以有符号比特的二进制数定义。正数和0的补码就是该数字本身再补上最高位元0。负数的补码则是将其[绝对值](https://zh.wikipedia.org/wiki/绝对值)按位取反再加1。

```txt
 9=0000 1001
-9=1111 0111
```

### 补码的计算规则

1. 补码运算时，其符号位与数值部分一起参加运算。
2. 补码的符号位相加后，如果有进位出现，要把这个进位舍去（自然丢失）。
3. 用补码运算，其运算结果亦为补码。

## 反码

将[二进制](https://zh.wikipedia.org/wiki/二进制)数每个数字反转，得到的数即为原二进制的**一的补码**（英语：ones' complement）。若某一位为0，则使其变为1，反之亦然。

```txt
 9=0000 1001
-9=1111 0110
```

# 整数以补码的方式存储

在计算机中码，整数是以补码进行存储。原因有以下点：

1. 统一 +0 和 -0 的表示方式；
2. 对于有符号整数进行统一计算；
3. 补码计算效率更高；

## +0 和 -0

首先来看下以原码、反码、补码对有符号 0 的表示：

```txt
原码：
+0=0000 0000
-0=1000 0000
反码：
+0=0000 0000
-0=1111 1111
补码
+0=0000 0000
-0=0000 0000
```

通过比较可以看到，补码在表示 -0 的时候，溢出的高位直接丢弃，最终二进制表示和 +0 一致，这是其他两个整数表示方式无法做到的。

## 统一计算

计算机最底层的算法应该是统一的，而不是需要针对不同的符号进行特定的算法，这无疑会增加 CPU 指令以及底层电子原件设计的难度。举个例子来说明：

```txt
-1 + 1 = 0
```

如果使用原码计算，带上符号位一起：

```txt
1000 0001
0000 0001
1000 0010
```

带上符号位计算，得到结果为 -2，这显然是不对的。

如果使用反码计算，带上符号位

```txt
1111 1110
0000 0001
1111 1111
```

带上符号位计算，得到结果为 -2^6，这个计算结果同样也不对。

使用补码计算，带上符号位一起：

```txt
1111 1111
0000 0001
0000 0000
```

带上符号位计算，得到的结果为 0，高位溢出直接丢弃。

通过计算比较，可见只有补码带上符号位计算的时候，计算结果是一致的。

## 计算效率高

通过前面的例子也可以看出，补码的运算是可以将减法转换成加法。这样依赖就不需要实现减法的 CPU 指令，并且在设计电子元器件的时候只需设置加法器。另一方面补码运算不需要考虑最高位溢出的情况，一旦发生溢出直接丢弃，计算效率更高。

