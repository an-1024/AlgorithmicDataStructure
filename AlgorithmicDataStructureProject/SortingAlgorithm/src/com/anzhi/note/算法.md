# 算法

什么是算法：

1. 解决具体的问题；
2. 有设计解决这个问题的具体流程；
3. 有评价处理流程的可量化指标；

## 举个例子说明

给定一个数N，然后计算 1! + 2! + 3! + ... + N! 的结果

那么此时可以有以下设计方案：

方案一：

每一步都展开计算，

```txt
1! = 1
2! = 1*2
3! = 1*2*3
以此类推
```

方案二：

利用上一步的结果：

```txt
1! = 1;
2! = 1! * 2;
3! = 2! * 3;
以此类推
```

两相比较，很明显第二个方案是比第一个方案好的。

方案一、和方案二代码实现如下：

```java
/**
 * 利用阶乘进行比较算法优劣，感受以下算法的优美
 */
public class AlgorithmDemo {
    // 方案一，将每一步都展开计算
    public static long function (int N) {
        int ans = 0;
        for (int i=0; i<N; i++){
            ans += function2(i);
        }
        return ans;
    }
    
    public static long function2 (int N) {
        int ans = 1;
        for (int i=0; i<N; i++) {
            ans *= i;
        }
        return ans;
    }
    
    // 方案二：每次记录上一个阶乘的值，然后与当前值相加
    public static long function3 (int N) {
        int ans = 0;
        int curr = 1; // 1 的阶乘
        for (int i=0; i<N; i++) {
            curr *= i;
            ans += curr;
        }
        return ans;
    }
}
```

可以看到方案二一个 for 循环就解决了。

## 选择排序

排序：故名思义就是将无序的数组进行排序，然后将其变成有序数组。

选择排序就是以选择的方式将数组数据变成有序。

假设有数组num [x, ...., N]，将其变为有序数组。

1. 遍历数组找到最小值，假设最小值的下标位 num[3]，那么此时将 num[3]  与 num[0] 交换位置。此时无序范围的数据就是从 1～N-1。
2. 接下来再从 1-N-1 中找到最小值，假设时num[4] 最小，然后num[4] 与 num[1] 交换位置，此时两个位置是有序的。此时无序范围变为 2 ～ N-1。以此类推。直到所有数据有序。

代码试下如下：

```java
 /**
 * 编写一个选择排序demo
 */
public class SelectSortedDemo {

    public static void main(String[] args) {
        // 创建一个数组
        int[] arr = new int[]{7, 0, 8, 9, 1, 4, 5, 1};
        // 打印排序之前的数组
        printArr(arr);
        // 对数组进行排序
        selectSortArr(arr);
        // 打印排序之后的数组
        printArr(arr);
    }

    // 对数组进行排序
    private static void selectSortArr(int[] arr) {
        // 考虑边界调节，不用排序直接返回
        if (arr == null || arr.length < 2) {
            return ;
        }
        
        // 按照之前的想法，开始找最小值
        // 0 ～ N-1;
        // 1 ～ N-1;
        // 2 ～ N-1;
        int N = arr.length;
        for (int i=0; i<N-1; i++) {
            // 0 ~ N-1
            // 1 ~ N-1
            // i ~ N-1
            // 从下标为 i 的开始循环，因此，最小值的下标是 
            int minNumIndex = i;
            // 遍历开始找最小值, 因为一旦左边确认一个最小值后，就不会再动它，因此
            for (int j=i+1; j<N; j++) {
                // 遍历所有值，找到最小值
                minNumIndex = arr[j] < arr[minNumIndex] ? j : minNumIndex;
            }
            // 找到最最小值之后要进行数据交换
            swapData(arr, i, minNumIndex);
        }
    }

    private static void swapData(int[] arr, int j, int minNumIndex) {
        int tmp = arr[minNumIndex];
        arr[minNumIndex] = arr[j];
        arr[j] = tmp;
    }

    private static void printArr(int[] arr) {
        for (int i=0; i<arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }
}
```

 

